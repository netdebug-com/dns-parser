use byteorder::{BigEndian, ByteOrder};
use {Error, Name};

#[derive(Debug, Clone, Copy)]
pub struct Record<'a> {
    pub target: Name<'a>,
}

impl<'a> super::Record<'a> for Record<'a> {
    const TYPE: isize = 65;

    fn parse(rdata: &'a [u8], original: &'a [u8]) -> super::RDataResult<'a> {
        if rdata.len() < 1 {
            return Err(Error::WrongRdataLength);
        }
        let record = Record {
            target: Name::scan(&rdata[0..], original)?,
        };
        Ok(super::RData::HTTPS(record))
    }
}

#[cfg(test)]
mod test {

    use Opcode::*;
    use QueryClass as QC;
    use QueryType as QT;
    use ResponseCode::NoError;
    use {Header, Packet};

    #[test]
    fn parse_response() {
        // from wireshark
        let response: [u8; 215] = [
            0x21, 0x8b, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x06, 0x6d,
            0x6f, 0x62, 0x69, 0x6c, 0x65, 0x06, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x04, 0x64,
            0x61, 0x74, 0x61, 0x09, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x03,
            0x63, 0x6f, 0x6d, 0x00, 0x00, 0x41, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x05, 0x00, 0x01,
            0x00, 0x00, 0x00, 0x6d, 0x00, 0x27, 0x06, 0x6d, 0x6f, 0x62, 0x69, 0x6c, 0x65, 0x06,
            0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x04, 0x64, 0x61, 0x74, 0x61, 0x0e, 0x74, 0x72,
            0x61, 0x66, 0x66, 0x69, 0x63, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x03, 0x6e,
            0x65, 0x74, 0x00, 0xc0, 0x3e, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x30, 0x00,
            0x29, 0x10, 0x6f, 0x6e, 0x65, 0x64, 0x73, 0x63, 0x6f, 0x6c, 0x70, 0x72, 0x64, 0x65,
            0x75, 0x73, 0x30, 0x37, 0x06, 0x65, 0x61, 0x73, 0x74, 0x75, 0x73, 0x08, 0x63, 0x6c,
            0x6f, 0x75, 0x64, 0x61, 0x70, 0x70, 0x05, 0x61, 0x7a, 0x75, 0x72, 0x65, 0xc0, 0x29,
            0xc0, 0x82, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x31, 0x07, 0x6e,
            0x73, 0x31, 0x2d, 0x32, 0x30, 0x31, 0x09, 0x61, 0x7a, 0x75, 0x72, 0x65, 0x2d, 0x64,
            0x6e, 0x73, 0xc0, 0x29, 0x06, 0x6d, 0x73, 0x6e, 0x68, 0x73, 0x74, 0xc0, 0x1f, 0x00,
            0x00, 0x27, 0x11, 0x00, 0x00, 0x03, 0x84, 0x00, 0x00, 0x01, 0x2c, 0x00, 0x09, 0x3a,
            0x80, 0x00, 0x00, 0x00, 0x3c,
        ];

        let packet = Packet::parse(&response).unwrap();
        assert_eq!(
            packet.header,
            Header {
                id: 0x218b,
                query: false,
                opcode: StandardQuery,
                authoritative: false,
                truncated: false,
                recursion_desired: true,
                recursion_available: true,
                authenticated_data: false,
                checking_disabled: false,
                response_code: NoError,
                questions: 1,
                answers: 2,
                nameservers: 1,
                additional: 0,
            }
        );
        assert_eq!(packet.questions.len(), 1);
        assert_eq!(packet.questions[0].qtype, QT::HTTPS);
        assert_eq!(packet.questions[0].qclass, QC::IN);
        assert_eq!(
            &packet.questions[0].qname.to_string()[..],
            "mobile.events.data.microsoft.com"
        );
    }
}
